{"code":"/**\r\n * demonstrate error report\r\n */\r\nimport { ReactPeg } from \"react-peg\";\r\nimport { Tracer } from \"pegjs-backtrace\";\r\n\r\nlet result = null;\r\n\r\nconst input = \"1.5 + 2 + 3.4 * ( 25 - 4 ) /  - 8\";\r\nconst tracer = new Tracer(input, { useColor: false });\r\n\r\ntry {\r\n    const parser = ReactPeg.render(<Expression />, { tracer });\r\n    const ast = parser.parse(input);\r\n    result = ast;\r\n} catch (error) {\r\n    result = error;\r\n}\r\n\r\nconst backtrace = tracer.getBacktraceString();\r\nconsole.log(backtrace);\r\nconsole.log(result);\r\n\r\nconst toExport = Boolean(result.message) ?  {\r\n    ...result,\r\n    backtrace\r\n} : result\r\n\r\nexport default toExport\r\n\r\n/**\r\n * grammar\r\n */\r\nfunction Expression() {\r\n\r\n    const head = (\r\n        <Term label=\"head\" />\r\n    );\r\n\r\n    const tail = (\r\n        <repeat label=\"tail\" type=\"*\">\r\n            <pattern action={({ term, op }) => ({ op, term })}>\r\n                <_ />\r\n                <or label=\"op\">\r\n                    <text>+</text>\r\n                    <text>-</text>\r\n                </or>\r\n                <Term label=\"term\" />\r\n                <_ />\r\n            </pattern>\r\n        </repeat>\r\n    );\r\n\r\n    const action = ({ head, tail }) => {\r\n        let value = head;\r\n        tail.forEach(({ op, term }) => {\r\n            if (op === \"+\") {\r\n                value += term;\r\n            } else if (op === \"-\") {\r\n                value -= term;\r\n            }\r\n        })\r\n        return value;\r\n    }\r\n\r\n    return (\r\n        <pattern action={action}>\r\n            {head}\r\n            {tail}\r\n        </pattern>\r\n    );\r\n}\r\n\r\nfunction _() {\r\n    return (\r\n        <repeat type=\"*\">\r\n            <set> \\t\\n\\r</set>\r\n        </repeat>\r\n    );\r\n}\r\n\r\nfunction Number() {\r\n    const digits = (\r\n        <repeat type=\"+\">\r\n            <set>0-9</set>\r\n        </repeat>\r\n    );\r\n\r\n    const action = ({ globalFunction }) => {\r\n        return parseFloat(globalFunction.text());\r\n    }\r\n\r\n    return (\r\n        <pattern action={action}>\r\n            {digits}\r\n            <opt>\r\n                <text>.</text>\r\n                {digits}\r\n            </opt>\r\n        </pattern>\r\n    );\r\n}\r\n\r\nfunction Factor() {\r\n\r\n    const number = (\r\n        <pattern action={({ value }) => value}>\r\n            <_ />\r\n            <Number label=\"value\" />\r\n            <_ />\r\n        </pattern>\r\n    );\r\n\r\n    const expression = (\r\n        <pattern action={({ expression }) => expression}>\r\n            <_ />\r\n            <text>(</text>\r\n            <Expression label=\"expression\" />\r\n            <text>)</text>\r\n            <_ />\r\n        </pattern >\r\n    );\r\n\r\n    return (\r\n        <or>\r\n            {expression}\r\n            {number}\r\n        </or>\r\n    );\r\n}\r\n\r\nfunction Term() {\r\n\r\n    const head = (\r\n        <Factor label=\"head\" />\r\n    );\r\n\r\n    const tail = (\r\n        <repeat label=\"tail\" type=\"*\">\r\n            <pattern action={({ op, factor }) => ({ op, factor })}>\r\n                <_ />\r\n                <or label=\"op\">\r\n                    <text>*</text>\r\n                    <text>/</text>\r\n                </or>\r\n                <Factor label=\"factor\" />\r\n                <_ />\r\n            </pattern>\r\n        </repeat>\r\n    );\r\n\r\n    const action = ({ head, tail }) => {\r\n        let value = head;\r\n        tail.forEach(({ op, factor }) => {\r\n            if (op === \"*\") {\r\n                value *= factor;\r\n            } else if (op === \"/\") {\r\n                value /= factor;\r\n            }\r\n        })\r\n        return value;\r\n    }\r\n\r\n    return (\r\n        <pattern action={action}>\r\n            {head}\r\n            {tail}\r\n        </pattern>\r\n    );\r\n}\r\n"}